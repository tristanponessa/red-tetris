[[notes]]


GENERAL:

    CLIENT
        es6
        functional programming 
        piece move logic has to be PURE FUNCTIONS  (exception: you can use oop nested classes for errors)
        gird Or flexbox (no svg/canvas/jquery)

    SERVER 
        oop (mst have min. class Player , Piece, Game)
    
BOILERPLATE
    42 provides a head start scripts
        to start the server 
        generate navigator needed js files 
        unit tests 

TESTS 
    your project must be worthy of a industry project 
    must cover 
    50% branches 
    70% statements functions lines



FRONTEND 

    board is 10 cols 20 rows lines 
    Super rotation system (original standard): 
        ~uses the rotation principal which envolves that a piece must be inside a box to rotate, this box can go threw pieces but piece cant rotate no more (except of modern tetris with wall kicks)
        ~cheat : 3rd and 4th roation correspond to 1st 2nd one row down.
    each person can see a ghost of other boards : can only see top of board of opponents baords with name, rest is hidden

    piece lands can still rotate until the next pull : the landed piece is in contact with the others so it cant move down but it can rotate. this is considered a pull
    rotate right only 

    game modes:
        solo mode : 
        multi : when a player destroys N lines , opponents receives N - 1 indestructible lines on the bottom

    pieces move
        steps (constant or unregular)
        constant speed [BONUS: n speed] also called gravity

    keys:

        r/l
        up : rotate only right 
        down : faster fall
        space auto fall (no extra rotate)

        BONUS: (modern tetris) key to switch pieces with a bonnus piece 


BACKEND 
    client is navigator (user uses browser)
    http communication (SPA)
    server must be coded with nodeJS (back must use a js engine)
    client/server communicate threw `socket.io` [event oriented/bidirectional] (back/front)
    persistance system not needed : saving states to files to avoid loosing proformance ()
    
    SERVER 
        jobs
            game management 
            piece distribution
            ghost players 
        network protocole: choose precisely after organising back front responsibilites
        nodejs http service + help of socket.io: since its asynchrone, it can distribute to all players at the same time index.html+bundle.js, make sure to use it or it would be a waste!
    
    GAME  MANAGEMENT 
        each player connectcs threw : http://<server_name_or_ip>:<port>/#<room>[<player_name>]
        first to connect is CONTROLLER (decides when to start + if to replay), if leaves , other random becomes 
        cant join in middle of game 
        end of game when only one remains 
        one player mode allowed
        multi games can run at same time 
        BONUS : apply limit to nb who can join 


    
    CLIENT 
        SPA
        -Redux: state management 
        -the navigator must receive index.html with <script ref="bundle.js"> which contains client code 
        -when no more client/server HTML exchanges, it is on its own to render the front and app logic  
            data must still be exchanged between client/server 
        [[(all allowed)lodash/ramda immutable.js redux-thunk redux-promise]]


BONUS:
    FRONT
        2nd version with FRP or flyd 
        scores
        game modes 
     
    MINE:
<<<<<<< HEAD
        make an android app (react native) + desktop app (electron)
        graphQL instead of SPA
        put it online for reals
        redo in TS 
        webassembly in C++
        C++ with CROW 
=======
        use functional programming instead of OOP in tetris game code
        make desktop version (electron)
        make app version (android React-Native)
        front in typescript (React + redux)
        redo in webAssembly & Rust in Front 
        back in Rust
        use rust Rocket API (if necessary)
        use graphQL instead of SPA 
>>>>>>> 1473875f70ef3833cf79fa3945ac004049f80874

    













